#!/bin/bash

install_hook() {
    git_root=$(git rev-parse --show-toplevel 2>/dev/null)
    if [ -z "$git_root" ]; then
        echo "Error: Not inside a Git repository."
        exit 1
    fi

    hook_type="pre-push"  # can optionally change to "pre-commit"
    hooks_dir="$git_root/.git/hooks"
    hook_file="$hooks_dir/$hook_type"

    # code check hook will call run-checks.sh
    cat > "$hook_file" <<EOL
#!/bin/bash
# Git hook generated by run-checks.sh

cd "$git_root"

bash "$git_root/run-checks.sh"

exit_code=\$?

exit \$exit_code
EOL

    chmod +x "$hook_file"
    echo "Code check hook installed at $hook_file"
    exit 0
}

remove_hook() {
    git_root=$(git rev-parse --show-toplevel 2>/dev/null)
    if [ -z "$git_root" ]; then
        echo "Error: Not inside a Git repository. Cannot remove code check hook."
        return
    fi

    hook_type="pre-push"  # can optionally change to "pre-commit"
    hooks_dir="$git_root/.git/hooks"
    hook_file="$hooks_dir/$hook_type"

    if [ -f "$hook_file" ] && grep -q "run-checks.sh" "$hook_file"; then
        rm "$hook_file"
        echo "Code check hook removed from $hook_file"
    else
        echo "Code check hook not found or was not installed by run-checks.sh."
    fi
}

if [[ "$1" == "--install-hook" ]]; then
    install_hook
    exit 0
elif [[ "$1" == "--remove-hook" ]]; then
    remove_hook
    exit 0
fi

commands=(
    "pnpm lint:prettier"
    "pnpm lint:eslint"
    "pnpm lint:filename"
    "pnpm lint:deps"
    "pnpm lint:remote-wallet-config"
    "pnpm lint:unused-exports"
    "pnpm audit-ci --high --skip-dev"
    "pnpm typecheck"
    "pnpm test:unit"
    "pnpm build"
)

colors=(
    "\033[33m"   # yellow
    "\033[92m"   # light green
    "\033[35m"   # pink
    "\033[34m"   # blue
    "\033[90m"   # gray
    "\033[36m"   # cyan
    "\033[94m"   # light blue
    "\033[95m"   # light pink
    "\033[96m"   # light cyan
)

NC="\033[0m"

pids=()
statuses=()
cmd_names=()
cmd_colors=()

run_command() {
    local cmd="$1"
    local color="$2"
    local name="$3"

    (
        set -o pipefail  
        bash -c "$cmd" 2>&1 | while IFS= read -r line; do
            echo -e "${color}[${name}]${NC} $line"
        done
        exit "${PIPESTATUS[0]}"
    ) &

    pid=$!
    pids+=("$pid")
    cmd_names+=("$name")
    cmd_colors+=("$color")
}

# starts each command in the background
for index in "${!commands[@]}"; do
    cmd="${commands[$index]}"
    color="${colors[$index % ${#colors[@]}]}"
    name="$(echo "$cmd" | awk '{print $1" "$2}')"
    run_command "$cmd" "$color" "$name"
done

# collect each command exit status
for index in "${!pids[@]}"; do
    pid="${pids[$index]}"
    name="${cmd_names[$index]}"
    if wait "$pid"; then
        statuses[$index]="succeeded"
    else
        statuses[$index]="failed"
    fi
done

echo -e "\nCode Check Summary:"
exit_code=0
for index in "${!commands[@]}"; do
    cmd="${commands[$index]}"
    status="${statuses[$index]}"
    color="${cmd_colors[$index]}"
    if [ "$status" == "succeeded" ]; then
        status_color="\033[1;32m"
        status_text="${status_color}SUCCESS${NC}"
    else
        status_color="\033[1;31m"
        status_text="${status_color}FAIL${NC}"
        exit_code=1
    fi
    echo -e "${color}[$cmd${NC}]: $status_text"
done

exit $exit_code